local require_dev = require "spec.helpers.require_dev"

describe("FunctionStatement transpilation", do
  require_dev()

  it("should support local function with one parameter", do
    local input = "local function hello(a) return a end; return hello(1), hello(2)"

    local tokens = Lexer.new(input):tokenize()
    local ast = Parser.new(tokens):parse()
    local result = Transpiler.new(ast):transpile()

    local program = Program.new(result):run()

    assert.equal(1, program.result[1])
    assert.equal(2, program.result[2])
  end)

  it("should support MemberExpression function using dot notation", do
    local input = "function a.b(c) return c end; return a.b(1), a.b(2)"

    local tokens = Lexer.new(input):tokenize()
    local ast = Parser.new(tokens):parse()
    local result = Transpiler.new(ast):transpile()

    local a = {}
    local program = Program.new(result, { a = a }):run()

    assert.equal(1, program.result[1])
    assert.equal(2, program.result[2])
  end)

  it("should support MemberExpression function using colon notation", do
    local input = "function a:b() return self end; return a:b()"

    local tokens = Lexer.new(input):tokenize()
    local ast = Parser.new(tokens):parse()
    local result = Transpiler.new(ast):transpile()

    local a = {}
    local program = Program.new(result, { a = a }):run()

    assert.equal(program.env.a, program.result[1])
  end)

  it("should support varargs", do
    local input = "function a(...) return {...} end; return a(1, 2), a(4, 'abc', false)"

    local tokens = Lexer.new(input):tokenize()
    local ast = Parser.new(tokens):parse()
    local result = Transpiler.new(ast):transpile()

    local program = Program.new(result):run()

    assert.equal(2, #program.result[1])
    assert.equal(1, program.result[1][1])
    assert.equal(2, program.result[1][2])

    assert.equal(3, #program.result[2])
    assert.equal(4, program.result[2][1])
    assert.equal("abc", program.result[2][2])
    assert.equal(false, program.result[2][3])
  end)

  it("should support optional parameters in function statements", do
    local input = [[
local function a(b, c = 1, d = "test")
  return { b, c, d }
end

return a(0), a(1, 2, "hello")
]]

    local tokens = Lexer.new(input):tokenize()
    local ast = Parser.new(tokens):parse()
    local result = Transpiler.new(ast):transpile()

    local program = Program.new(result):run()

    assert.equal(0, program.result[1][1])
    assert.equal(1, program.result[1][2])
    assert.equal("test", program.result[1][3])

    assert.equal(1, program.result[2][1])
    assert.equal(2, program.result[2][2])
    assert.equal("hello", program.result[2][3])
  end)

  it("should support function expressions", do
    local input = "local a = function(b) return b end; return a(1), a(2)"

    local tokens = Lexer.new(input):tokenize()
    local ast = Parser.new(tokens):parse()
    local result = Transpiler.new(ast):transpile()

    local program = Program.new(result):run()

    assert.equal(1, program.result[1])
    assert.equal(2, program.result[2])
  end)

  it("should support lambda expressions that does not implicitly return", do
    local input = "return do return 1 end"

    local tokens = Lexer.new(input):tokenize()
    local ast = Parser.new(tokens):parse()
    local result = Transpiler.new(ast):transpile()

    local program = Program.new(result):run()

    assert.equal(1, program.result[1]())
  end)

  it("should support lambda expresssions that has parameters and does not implicitly return", do
    local input = "return |a, b| do return a + b end"

    local tokens = Lexer.new(input):tokenize()
    local ast = Parser.new(tokens):parse()
    local result = Transpiler.new(ast):transpile()

    local program = Program.new(result):run()

    assert.equal(2, program.result[1](1, 1))
    assert.equal(4, program.result[1](1, 3))
  end)

  it("should support lambda expresssions that has parameters and does implicitly return", do
    local input = "return |a, b| a + b"

    local tokens = Lexer.new(input):tokenize()
    local ast = Parser.new(tokens):parse()
    local result = Transpiler.new(ast):transpile()

    local program = Program.new(result):run()

    assert.equal(2, program.result[1](1, 1))
    assert.equal(4, program.result[1](1, 3))
  end)

  it("should support lambda expresssions that has no parameters and does implicitly return", do
    local input = "return || 1"

    local tokens = Lexer.new(input):tokenize()
    local ast = Parser.new(tokens):parse()
    local result = Transpiler.new(ast):transpile()

    local program = Program.new(result):run()

    assert.equal(1, program.result[1]())
    assert.equal(1, program.result[1]())
  end)

  it("should support function expressions with default parameters", do
    local input = "return function(a = 'hi') return a end"

    local tokens = Lexer.new(input):tokenize()
    local ast = Parser.new(tokens):parse()
    local result = Transpiler.new(ast):transpile()

    local program = Program.new(result):run()

    assert.equal("hi", program.result[1]())
    assert.equal("hello", program.result[1]("hello"))
  end)

  it("should support lambda expressions with default parameters", do
    local input = "return |a = 'hi'| a"

    local tokens = Lexer.new(input):tokenize()
    local ast = Parser.new(tokens):parse()
    local result = Transpiler.new(ast):transpile()

    local program = Program.new(result):run()

    assert.equal("hi", program.result[1]())
    assert.equal("hello", program.result[1]("hello"))
  end)
end)
